已实现的有：共121题

剑指offer第2版：共75题
简单：共41题
中等：共29题
难：共5题

================================================

复刷顺序：
第一类：1) frequency-5
       2) bitmap-5
-----------------------------------------第1天
       3) sort-5
       4) string-4
       5) hash-4
-----------------------------------------第2天
第二类：6) array-18
-----------------------------------------第3天
       7) heap-3
       8) stack-7
-----------------------------------------第4天
       9) linkedlist-11
-----------------------------------------第5天
       10) tree-21
-----------------------------------------第6天
第三类：11) recursion-2
       12) bfs-0
       13) dfs-1
       14) divide-2
       15) greedy-2
-----------------------------------------第7天
       16) backtrack-10
-----------------------------------------第8天
       17) dynamic-23
-----------------------------------------第9天

==================================================



========================================================================================================================
frequency
7. 整数反转 ***
9. 回文数 ***
48. 旋转图像 ???? 先转置再反转行
146. LRU缓存机制 ***  双向链表 + HashMap
208. 实现 Trie (前缀树)

bitmap	位运算
136. 只出现一次的数字 ***
191. 位1的个数 ***
231. 2的幂 ***
338. 比特位计数 ***
461. 汉明距离 ***

sort
冒泡排序 sort/BubbleSort （n2 稳定） ***
选择排序 sort/ChoiceSort （n2 稳定） ***
插入排序 sort/InsertSort (n2 不稳定) ***
归并排序 sort/MergeSort （nlogn 稳定，非原地排序） ***
快速排序 sort/QuickSort （nlogn 不稳定）**

string
3. 无重复字符的最长子串 *** 	滑动窗口
5. 最长回文子串	动态规划
14. 最长公共前缀 ***
415. 字符串相加

hash
15. 三数之和 ***		排序+双指针
18. 四数之和 ???		排序+双指针
49. 字母异位词分组 ***	排序+map
242. 有效的字母异位词 ***		哈希表

array
剑指 Offer 29. 顺时针打印矩阵		left right top bottom
剑指 Offer 57 - II. 和为s的连续正数序列	滑动窗口法
1. 两数之和
11. 盛最多水的容器 双指针
26. 删除排序数组中的重复项 双指针，return i+1;
27. 移除元素		双指针，return i;
283. 移动零 双指针(方法同27题移除元素)
34. 在排序数组中查找元素的第一个和最后一个位置	二分查找
56. 合并区间		排序
69. x 的平方根 ***	二分法
88. 合并两个有序数组 ***  p1,p2,p3=p1+p2
238. 除自身以外数组的乘积	先求出左右两边的乘积再相乘
240. 搜索二维矩阵 II		从左下角开始
287. 寻找重复数		排序迭代/快慢指针
448. 找到所有数组中消失的数字 		迭代并赋值为-1，最后大于0的既满足（数组中数都大于0）
581. 最短无序连续子数组			排序迭代对比
674. 最长连续递增序列 ***			滑动窗口
704. 二分查找 ***

heap/Heap
堆的基本操作：堆化，大根堆，小根堆，堆排序
215. 数组中的第K个最大元素 ***    优先级队列 PriorityQueue-小根堆，比较元素默认int的自然升序排序
347. 前K个高频元素 ***            PriorityQueue-小根堆，自定义比较器比较频次
703. 数据流中的第K大元素 ***      优先级队列 PriorityQueue-小根堆,创建类和两个属性 limit 和 queue，构造函数构造好初始数据

stack/queue
20. 有效的括号 ***       栈+HashMap
155. 最小栈 ***          维护两个栈，增删-合理操作两个栈，获取操作相应栈
225. 用队列实现栈 ***     q2入栈，q1出栈（注意入栈逻辑）
232. 用栈实现队列 ***     s1入队列，s2出队列（注意出队列逻辑）
227. 基本计算器 II ***    加减直接入栈正数或负数，乘除先取出栈顶元素乘以或除以新元素，将结果入栈
239. 滑动窗口最大值 *** ???    LinkedList双向链表队列，构建递减队列，添加，超过长度删除并写入最大值
496. 下一个更大元素 I ***      单调栈，栈和HashMap配合实现

linkedlist
2. 两数相加 ***                 与 415. 数字型字符串相加 有异曲同工之妙
21. 合并两个有序链表 ***          while循环比对，并next
19. 删除链表的倒数第N个节点 ***    双指针法、栈、迭代len-n+1，推荐使用快慢双指针法
83. 删除排序链表中的重复元素 ***   同26.删除排序数组中的重复元素
24. 两两交换链表中的节点 ***      画图演示，看图写代码，声明两链表，while next和next.next都不为空
206. 反转链表 *******           声明双指针pre=null, curr = head;curr.next = pre(链表指针反转)，最后返回pre
92. 反转链表 II 指定长度反转      双指针头插法-删除结点递推，画图演示，想图写代码
25 K 个一组翻转链表 ???         （推荐）链表分区(已翻转，待翻转，未翻转)，pre，end，start=pre.next，nextTemp=end.next指针,pre和end移动指针到翻转后的start位置
160 相交链表 ***                 双指针法（a+c+b = b+c+a）a=链表1未相交部分，b=链表2未相交部分，c=两链表相交部分
141 环形链表（判断链表是否有环）    1-哈希表；（推荐）2-双指针法-快慢指针 while(fast != null && fast.next != null)
142 环形链表 II ***(找出入环点)    1-哈希表；（推荐）2-快慢指针
//148. 排序链表

tree
94. 二叉树的中序遍历            递归和迭代都要会，推荐迭代（一个stack实现）Stack<TreeNode> stack = new Stack<>();（两层while循环，内层放左子树）
144. 二叉树的前序遍历 *****     递归和迭代都要会，推荐迭代（一个stack实现）while(!stack.isEmpty())
145. 后序遍历二叉树             递归和迭代都要会，推荐迭代（两个stack实现）
102. 二叉树的层序遍历 *****     BFS（一个queue实现）Queue<TreeNode> queue = new LinkedList<>(); 写法同107
107. 二叉树的层次遍历 II （自底向上的层次遍历）    BFS（一个queue实现）1-使用队列存储每层元素，用栈存储每层的结果集；2-(推荐)使用java的LinkedList的性质，从上到下遍历，将新遍历的层结果集放入linkedlist的头部
103. 二叉树的锯齿形层次遍历 *****      使用两个stack交替迭代放值
104. 二叉树的最大深度 ***             1-递归；2-（推荐）层次遍历+累加深度（广度优先搜索）
111. 二叉树的最小深度 ***             1-深度优先搜索，即递归；2-层次遍历，相比104题，多加一个判断，判断是否已经到叶子结点，到了直接return depth（if (node.left == null && node.right == null) ）
199. 二叉树的右视图 *****             1-广度优先搜索，即层次遍历（推荐）将每一层的最后一个节点放入结果列表
543. 二叉树的直径                     递归，左子树的深度+右子树的深度 Math.max(ans, leftDepth + rightDepth);return Math.max(leftDepth, rightDepth) + 1;
101. 对称二叉树 *****        迭代：队列，放左右结点和右左结点
226. 翻转二叉树 *****        迭代：用queue层次遍历交换处理,循环体内，每次取出一个node
617. 合并二叉树              递归
96. 不同的二叉搜索树          动态规划,i为根，G(i-1)*G(n-i) 求和（1<= i <=n）
98. 验证二叉搜索树???         中序遍历：遍历后是升序
235. 二叉搜索树的最近公共祖先 *****     while循环判断根的值和另两个参数的大小。while (root != null) {
236. 二叉树的最近公共祖先 ***           递归
538. 把二叉搜索树转换为累加树           递归-反序中序遍历
112. 路径总和 *** 判断是否存在                             层次遍历(BFS推荐)
113. 路径之和 II *** 返回所有路径                          同112，用map把结点父节点记录下来，最后求路径反转
437. 路径之和 III *** 不需要到叶子结点返回所有路径的数量      两层递归

recursion
汉诺塔问题 HanNuoTa
172. 阶乘后的零 *** (打印阶乘 Recursion)

bfs

dfs
22. 括号生成 ***

divide
50. Pow(x, n) ***
169. 多数元素 ***

greedy
122. 买卖股票的最佳时机 II ***
55. 跳跃游戏


backtrack
36. 有效的数独
39. 组合总和 ***
40. 组合总和 II ***
46. 全排列 ***
47. 全排列II ***
51. N皇后 *** ??
79. 单词搜索 ????
78. 子集 ***
90. 子集II***
0-1背包问题 /backtrack/ZeroOneBag

dynamic
0-1背包问题 /dynamicprogramming/ZeroOndBag3
70. 爬楼梯 ***
120. 三角形最小路径和 ***
64. 最小路径和 ***
121、(122)、123、188、309、714 股票买卖系列 ***
53. 最大子序和 ***
152. 乘积最大子数组***
300. 最长上升子序列 ***
322. 零钱兑换、 518.零钱兑换 II ***
72. 编辑距离 ***
62. 不同路径 ***
279. 完全平方数 ***
343. 整数拆分 ***
416. 分割等和子集 ***
474. 一和零 ***
494. 目标和 ***
198. 打家劫舍 ***
213. 打家劫舍 II ***
337. 打家劫舍 III ***