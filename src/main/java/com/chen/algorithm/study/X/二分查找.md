

> 假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 
> 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？

### 二分查找应用场景的局限性

1.有序；
2.线性结构，也就是数组存储；
3.数据量太小，二分查找的优势体现不出来；
4.太大也不合适，二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性

### 二分查找的总结

> 二分查找，它的时间复杂度是 O(logn)。

> 二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。

> 但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。

> 二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，

> 二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。

### 二分查找的特殊情况

二分查找中有序的数组中有重复的元素

假如查找的值是有重复元素，则查找重复元素的第一个元素
````

public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      if ((mid == 0) || (a[mid - 1] != value)) {
        return mid;
    }else{
     else high = mid - 1;
     }
    }
  }
  return -1;
}
````

